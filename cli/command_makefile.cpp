#include "cli_common.hpp"
#include <filesystem>
#include <common/logging.hpp>

namespace yarnpath::cli {

int command_makefile(int argc, char** argv) {
    auto log = yarnpath::logging::get_logger();

    try {
        std::string directory;
        std::string executable = "yarnpath";  // Default to PATH
        std::string input_path;
        std::string config_path;
        bool verbose = false;

        // Parse arguments
        for (int i = 2; i < argc; ++i) {
            std::string arg = argv[i];
            if (arg == "-C") {
                if (i + 1 < argc) {
                    directory = argv[++i];
                } else {
                    throw std::runtime_error("-C requires a directory argument");
                }
            } else if (arg == "--executable") {
                if (i + 1 < argc) {
                    executable = argv[++i];
                } else {
                    throw std::runtime_error("--executable requires a path argument");
                }
            } else if (arg == "-c" || arg == "--config") {
                if (i + 1 < argc) {
                    config_path = argv[++i];
                } else {
                    throw std::runtime_error("-c/--config requires a path argument");
                }
            } else if (arg == "-v" || arg == "--verbose") {
                verbose = true;
            } else if (arg == "-h" || arg == "--help") {
                std::cerr << "Usage: yarnpath generate-makefile <input.txt> -C <directory> [options]\n";
                std::cerr << "\nOptions:\n";
                std::cerr << "  -C <directory>       Target directory for Makefile and outputs\n";
                std::cerr << "  -c, --config <file>  Configuration file to use for surface step\n";
                std::cerr << "  --executable <path>  Path to yarnpath executable (default: yarnpath in PATH)\n";
                std::cerr << "  -v, --verbose        Enable verbose output\n";
                return 0;
            } else if (arg[0] != '-') {
                if (input_path.empty()) {
                    input_path = arg;
                } else {
                    throw std::runtime_error("Unexpected argument: " + arg);
                }
            } else {
                throw std::runtime_error("Unknown option: " + arg);
            }
        }

        if (input_path.empty() || directory.empty()) {
            std::cerr << "Usage: yarnpath generate-makefile <input.txt> -C <directory> [options]\n";
            std::cerr << "\n";
            std::cerr << "Options:\n";
            std::cerr << "  -C <directory>       Target directory for Makefile and outputs\n";
            std::cerr << "  -c, --config <file>  Configuration file to use for surface step\n";
            std::cerr << "  --executable <path>  Path to yarnpath executable (default: yarnpath in PATH)\n";
            std::cerr << "  -v, --verbose        Enable verbose output\n";
            std::cerr << "\n";
            std::cerr << "Example:\n";
            std::cerr << "  yarnpath generate-makefile pattern.txt -C build/pattern\n";
            std::cerr << "  yarnpath generate-makefile pattern.txt -C build/pattern -c config.json\n";
            return 1;
        }

        log->info("Generating Makefile in directory: {}", directory);
        log->info("Input pattern: {}", input_path);
        log->info("Yarnpath executable: {}", executable);
        if (!config_path.empty()) {
            log->info("Config file: {}", config_path);
        }

        // Create directory
        std::filesystem::create_directories(directory);

        // Get absolute path to input
        std::filesystem::path abs_input = std::filesystem::absolute(input_path);
        std::string input_basename = abs_input.stem().string();

        // Get absolute path to config if provided
        std::string abs_config;
        if (!config_path.empty()) {
            abs_config = std::filesystem::absolute(config_path).string();
        }

        // Generate Makefile content
        std::ostringstream makefile;
        makefile << "# Auto-generated Makefile for yarnpath pipeline\n";
        makefile << "# Input: " << abs_input.string() << "\n";
        if (!abs_config.empty()) {
            makefile << "# Config: " << abs_config << "\n";
        }
        makefile << "# Generated by: yarnpath generate-makefile\n";
        makefile << "\n";
        makefile << "YARNPATH := " << executable << "\n";
        makefile << "INPUT := " << abs_input.string() << "\n";
        makefile << "BASENAME := " << input_basename << "\n";
        if (!abs_config.empty()) {
            makefile << "CONFIG := " << abs_config << "\n";
        }
        makefile << "\n";
        makefile << "# Intermediate files\n";
        makefile << "INSTRUCTIONS := $(BASENAME).instructions.json\n";
        makefile << "STITCH := $(BASENAME).stitch.json\n";
        makefile << "YARN := $(BASENAME).yarn.json\n";
        makefile << "SURFACE := $(BASENAME).surface.json\n";
        makefile << "GEOMETRY := $(BASENAME).geometry.json\n";
        makefile << "OBJ := $(BASENAME).obj\n";
        makefile << "\n";
        makefile << "# Default target\n";
        makefile << "all: $(OBJ)\n";
        makefile << "\n";
        makefile << "# Pipeline steps\n";
        makefile << "$(INSTRUCTIONS): $(INPUT) $(YARNPATH)\n";
        makefile << "\t$(YARNPATH) parse $(INPUT) -o $(INSTRUCTIONS)\n";
        makefile << "\n";
        makefile << "$(STITCH): $(INSTRUCTIONS) $(YARNPATH)\n";
        makefile << "\t$(YARNPATH) stitch $(INSTRUCTIONS) -o $(STITCH)\n";
        makefile << "\n";
        makefile << "$(YARN): $(STITCH) $(YARNPATH)\n";
        makefile << "\t$(YARNPATH) yarn $(STITCH) -o $(YARN)\n";
        makefile << "\n";
        if (!abs_config.empty()) {
            makefile << "$(SURFACE): $(YARN) $(CONFIG) $(YARNPATH)\n";
            makefile << "\t$(YARNPATH) surface $(YARN) -o $(SURFACE) -c $(CONFIG)\n";
        } else {
            makefile << "$(SURFACE): $(YARN) $(YARNPATH)\n";
            makefile << "\t$(YARNPATH) surface $(YARN) -o $(SURFACE)\n";
        }
        makefile << "\n";
        makefile << "$(GEOMETRY): $(SURFACE) $(YARNPATH)\n";
        makefile << "\t$(YARNPATH) geometry $(SURFACE) -o $(GEOMETRY)\n";
        makefile << "\n";
        makefile << "$(OBJ): $(GEOMETRY) $(YARNPATH)\n";
        makefile << "\t$(YARNPATH) obj $(GEOMETRY) -o $(OBJ)\n";
        makefile << "\n";
        makefile << "# Convenience targets for intermediate steps\n";
        makefile << ".PHONY: instructions stitch yarn surface geometry clean\n";
        makefile << "instructions: $(INSTRUCTIONS)\n";
        makefile << "stitch: $(STITCH)\n";
        makefile << "yarn: $(YARN)\n";
        makefile << "surface: $(SURFACE)\n";
        makefile << "geometry: $(GEOMETRY)\n";
        makefile << "\n";
        makefile << "clean:\n";
        makefile << "\trm -f $(INSTRUCTIONS) $(STITCH) $(YARN) $(SURFACE) $(GEOMETRY) $(OBJ)\n";
        makefile << "\n";
        makefile << ".PHONY: all clean\n";

        // Write Makefile
        std::string makefile_path = directory + "/Makefile";
        write_file(makefile_path, makefile.str());

        log->info("Generated Makefile at: {}", makefile_path);
        std::cerr << "Generated Makefile at: " << makefile_path << "\n";
        std::cerr << "\nTo build the pipeline:\n";
        std::cerr << "  cd " << directory << "\n";
        std::cerr << "  make\n";
        std::cerr << "\nIntermediate targets:\n";
        std::cerr << "  make instructions  - Stop after parse\n";
        std::cerr << "  make stitch       - Stop after stitch graph\n";
        std::cerr << "  make yarn         - Stop after yarn path\n";
        std::cerr << "  make surface      - Stop after surface relaxation\n";
        std::cerr << "  make geometry     - Stop after geometry generation\n";
        std::cerr << "  make clean        - Remove all generated files\n";

        return 0;

    } catch (const std::exception& e) {
        log->error("Error: {}", e.what());
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }
}

}  // namespace yarnpath::cli
